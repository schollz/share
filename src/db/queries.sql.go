// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const approveDeviceAuthSession = `-- name: ApproveDeviceAuthSession :one
UPDATE device_auth_sessions
SET approved = TRUE, user_id = $1, token = $2
WHERE user_code = $3 AND approved = FALSE
RETURNING id, device_code, user_code, user_id, approved, token, expires_at, created_at
`

type ApproveDeviceAuthSessionParams struct {
	UserID   sql.NullInt64  `json:"user_id"`
	Token    sql.NullString `json:"token"`
	UserCode string         `json:"user_code"`
}

func (q *Queries) ApproveDeviceAuthSession(ctx context.Context, arg ApproveDeviceAuthSessionParams) (DeviceAuthSession, error) {
	row := q.db.QueryRowContext(ctx, approveDeviceAuthSession, arg.UserID, arg.Token, arg.UserCode)
	var i DeviceAuthSession
	err := row.Scan(
		&i.ID,
		&i.DeviceCode,
		&i.UserCode,
		&i.UserID,
		&i.Approved,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createDeviceAuthSession = `-- name: CreateDeviceAuthSession :one
INSERT INTO device_auth_sessions (device_code, user_code, expires_at)
VALUES ($1, $2, $3)
RETURNING id, device_code, user_code, user_id, approved, token, expires_at, created_at
`

type CreateDeviceAuthSessionParams struct {
	DeviceCode string    `json:"device_code"`
	UserCode   string    `json:"user_code"`
	ExpiresAt  time.Time `json:"expires_at"`
}

// Device Auth Sessions
func (q *Queries) CreateDeviceAuthSession(ctx context.Context, arg CreateDeviceAuthSessionParams) (DeviceAuthSession, error) {
	row := q.db.QueryRowContext(ctx, createDeviceAuthSession, arg.DeviceCode, arg.UserCode, arg.ExpiresAt)
	var i DeviceAuthSession
	err := row.Scan(
		&i.ID,
		&i.DeviceCode,
		&i.UserCode,
		&i.UserID,
		&i.Approved,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (user_id, encrypted_filename, file_size, encrypted_key, share_token, download_count, file_data)
VALUES ($1, $2, $3, $4, $5, 0, $6)
RETURNING id, user_id, encrypted_filename, file_size, encrypted_key, share_token, download_count, created_at, updated_at, file_data
`

type CreateFileParams struct {
	UserID            int64          `json:"user_id"`
	EncryptedFilename string         `json:"encrypted_filename"`
	FileSize          int64          `json:"file_size"`
	EncryptedKey      string         `json:"encrypted_key"`
	ShareToken        sql.NullString `json:"share_token"`
	FileData          []byte         `json:"file_data"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, createFile,
		arg.UserID,
		arg.EncryptedFilename,
		arg.FileSize,
		arg.EncryptedKey,
		arg.ShareToken,
		arg.FileData,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EncryptedFilename,
		&i.FileSize,
		&i.EncryptedKey,
		&i.ShareToken,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileData,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, encryption_salt, subscriber, verified, verification_token)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, email, password_hash, encryption_salt, created_at, updated_at, subscriber, verified, verification_token
`

type CreateUserParams struct {
	Email             string         `json:"email"`
	PasswordHash      string         `json:"password_hash"`
	EncryptionSalt    string         `json:"encryption_salt"`
	Subscriber        int32          `json:"subscriber"`
	Verified          int32          `json:"verified"`
	VerificationToken sql.NullString `json:"verification_token"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.EncryptionSalt,
		arg.Subscriber,
		arg.Verified,
		arg.VerificationToken,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.EncryptionSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subscriber,
		&i.Verified,
		&i.VerificationToken,
	)
	return i, err
}

const deleteExpiredDeviceAuthSessions = `-- name: DeleteExpiredDeviceAuthSessions :exec
DELETE FROM device_auth_sessions
WHERE expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredDeviceAuthSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredDeviceAuthSessions)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1 AND user_id = $2
`

type DeleteFileParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) error {
	_, err := q.db.ExecContext(ctx, deleteFile, arg.ID, arg.UserID)
	return err
}

const deleteFileByID = `-- name: DeleteFileByID :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFileByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteFileByID, id)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserByID, id)
	return err
}

const getDeviceAuthSessionByDeviceCode = `-- name: GetDeviceAuthSessionByDeviceCode :one
SELECT id, device_code, user_code, user_id, approved, token, expires_at, created_at FROM device_auth_sessions
WHERE device_code = $1
LIMIT 1
`

func (q *Queries) GetDeviceAuthSessionByDeviceCode(ctx context.Context, deviceCode string) (DeviceAuthSession, error) {
	row := q.db.QueryRowContext(ctx, getDeviceAuthSessionByDeviceCode, deviceCode)
	var i DeviceAuthSession
	err := row.Scan(
		&i.ID,
		&i.DeviceCode,
		&i.UserCode,
		&i.UserID,
		&i.Approved,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getDeviceAuthSessionByUserCode = `-- name: GetDeviceAuthSessionByUserCode :one
SELECT id, device_code, user_code, user_id, approved, token, expires_at, created_at FROM device_auth_sessions
WHERE user_code = $1
LIMIT 1
`

func (q *Queries) GetDeviceAuthSessionByUserCode(ctx context.Context, userCode string) (DeviceAuthSession, error) {
	row := q.db.QueryRowContext(ctx, getDeviceAuthSessionByUserCode, userCode)
	var i DeviceAuthSession
	err := row.Scan(
		&i.ID,
		&i.DeviceCode,
		&i.UserCode,
		&i.UserID,
		&i.Approved,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, user_id, encrypted_filename, file_size, encrypted_key, share_token, download_count, created_at, updated_at, file_data FROM files
WHERE id = $1 AND user_id = $2
LIMIT 1
`

type GetFileByIDParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetFileByID(ctx context.Context, arg GetFileByIDParams) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByID, arg.ID, arg.UserID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EncryptedFilename,
		&i.FileSize,
		&i.EncryptedKey,
		&i.ShareToken,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileData,
	)
	return i, err
}

const getFileByShareToken = `-- name: GetFileByShareToken :one
SELECT id, user_id, encrypted_filename, file_size, encrypted_key, share_token, download_count, created_at, updated_at, file_data FROM files
WHERE share_token = $1
LIMIT 1
`

func (q *Queries) GetFileByShareToken(ctx context.Context, shareToken sql.NullString) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByShareToken, shareToken)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EncryptedFilename,
		&i.FileSize,
		&i.EncryptedKey,
		&i.ShareToken,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileData,
	)
	return i, err
}

const getFilesByUserID = `-- name: GetFilesByUserID :many
SELECT id, user_id, encrypted_filename, file_size, encrypted_key, share_token, download_count, created_at, updated_at, file_data FROM files
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetFilesByUserID(ctx context.Context, userID int64) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, getFilesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EncryptedFilename,
			&i.FileSize,
			&i.EncryptedKey,
			&i.ShareToken,
			&i.DownloadCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FileData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalStorageByUserID = `-- name: GetTotalStorageByUserID :one
SELECT COALESCE(SUM(file_size), 0)::bigint as total_storage
FROM files
WHERE user_id = $1
`

func (q *Queries) GetTotalStorageByUserID(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalStorageByUserID, userID)
	var total_storage int64
	err := row.Scan(&total_storage)
	return total_storage, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, encryption_salt, created_at, updated_at, subscriber, verified, verification_token FROM users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.EncryptionSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subscriber,
		&i.Verified,
		&i.VerificationToken,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, encryption_salt, created_at, updated_at, subscriber, verified, verification_token FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.EncryptionSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subscriber,
		&i.Verified,
		&i.VerificationToken,
	)
	return i, err
}

const getUserByVerificationToken = `-- name: GetUserByVerificationToken :one
SELECT id, email, password_hash, encryption_salt, created_at, updated_at, subscriber, verified, verification_token FROM users
WHERE verification_token = $1
LIMIT 1
`

func (q *Queries) GetUserByVerificationToken(ctx context.Context, verificationToken sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByVerificationToken, verificationToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.EncryptionSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subscriber,
		&i.Verified,
		&i.VerificationToken,
	)
	return i, err
}

const incrementDownloadCountByToken = `-- name: IncrementDownloadCountByToken :one
UPDATE files
SET download_count = download_count + 1, updated_at = CURRENT_TIMESTAMP
WHERE share_token = $1
RETURNING id, user_id, encrypted_filename, file_size, encrypted_key, share_token, download_count, created_at, updated_at, file_data
`

func (q *Queries) IncrementDownloadCountByToken(ctx context.Context, shareToken sql.NullString) (File, error) {
	row := q.db.QueryRowContext(ctx, incrementDownloadCountByToken, shareToken)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EncryptedFilename,
		&i.FileSize,
		&i.EncryptedKey,
		&i.ShareToken,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileData,
	)
	return i, err
}

const updateFileEncryption = `-- name: UpdateFileEncryption :exec
UPDATE files
SET encrypted_filename = $1, encrypted_key = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $3 AND user_id = $4
`

type UpdateFileEncryptionParams struct {
	EncryptedFilename string `json:"encrypted_filename"`
	EncryptedKey      string `json:"encrypted_key"`
	ID                int64  `json:"id"`
	UserID            int64  `json:"user_id"`
}

func (q *Queries) UpdateFileEncryption(ctx context.Context, arg UpdateFileEncryptionParams) error {
	_, err := q.db.ExecContext(ctx, updateFileEncryption,
		arg.EncryptedFilename,
		arg.EncryptedKey,
		arg.ID,
		arg.UserID,
	)
	return err
}

const updateFileShareToken = `-- name: UpdateFileShareToken :one
UPDATE files
SET share_token = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2 AND user_id = $3
RETURNING id, user_id, encrypted_filename, file_size, encrypted_key, share_token, download_count, created_at, updated_at, file_data
`

type UpdateFileShareTokenParams struct {
	ShareToken sql.NullString `json:"share_token"`
	ID         int64          `json:"id"`
	UserID     int64          `json:"user_id"`
}

func (q *Queries) UpdateFileShareToken(ctx context.Context, arg UpdateFileShareTokenParams) (File, error) {
	row := q.db.QueryRowContext(ctx, updateFileShareToken, arg.ShareToken, arg.ID, arg.UserID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EncryptedFilename,
		&i.FileSize,
		&i.EncryptedKey,
		&i.ShareToken,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileData,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           int64  `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const verifyUserByToken = `-- name: VerifyUserByToken :one
UPDATE users
SET verified = 1, verification_token = NULL, updated_at = CURRENT_TIMESTAMP
WHERE verification_token = $1
RETURNING id, email, password_hash, encryption_salt, created_at, updated_at, subscriber, verified, verification_token
`

func (q *Queries) VerifyUserByToken(ctx context.Context, verificationToken sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, verifyUserByToken, verificationToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.EncryptionSalt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Subscriber,
		&i.Verified,
		&i.VerificationToken,
	)
	return i, err
}
